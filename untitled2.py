# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zi5tuVOdssD_FKw6Zw5BintlAM-1FvfR
"""

from google.colab import drive
drive.mount('/content/drive')

import warnings, os, joblib
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
from dataclasses import dataclass
from sklearn.ensemble import RandomForestRegressor

# ----------------------------- CONFIG -----------------------------
RF_KW = dict(n_estimators=50, max_depth=8, min_samples_leaf=5, random_state=42, n_jobs=-1)
CACHE_DIR = "/content/drive/MyDrive/Cache"
os.makedirs(CACHE_DIR, exist_ok=True)
SALARY_CAP = 350_000_000  # MLB soft cap (adjustable)

@dataclass
class LahmanPaths:
    batting_csv: str
    fielding_csv: str
    pitching_csv: str
    salaries_csv: str
    teams_csv: str
    people_csv: str

paths = LahmanPaths(
    batting_csv="/content/drive/MyDrive/Batting.csv",
    fielding_csv="/content/drive/MyDrive/Fielding.csv",
    pitching_csv="/content/drive/MyDrive/Pitching.csv",
    salaries_csv="/content/drive/MyDrive/Salaries.csv",
    teams_csv="/content/drive/MyDrive/Teams.csv",
    people_csv="/content/drive/MyDrive/People.csv"
)

# ----------------------------- CACHED DATA LOADER -----------------------------
_data_cache = {}
def load_csv_cached(path):
    if path not in _data_cache:
        _data_cache[path] = pd.read_csv(path)
    return _data_cache[path]

# ----------------------------- UTILS -----------------------------
def safe_div(a, b): return np.divide(a, np.where(b==0, np.nan, b))
def scale_20_80(x, lo, hi): return 20 + 60*(x.clip(lo,hi)-lo)/(hi-lo+1e-9)
def train_rf(X, y): m=RandomForestRegressor(**RF_KW); m.fit(X,y); return m
def format_money(val): return f"${val:,.0f}"

# ----------------------------- BATTERS -----------------------------
def build_batter_df(year, paths):
    bat = load_csv_cached(paths.batting_csv)
    fld = load_csv_cached(paths.fielding_csv)
    ppl = load_csv_cached(paths.people_csv)
    sal = load_csv_cached(paths.salaries_csv)

    # Ensure playerID is string in all DataFrames
    bat["playerID"] = bat["playerID"].astype(str)
    fld["playerID"] = fld["playerID"].astype(str)
    ppl["playerID"] = ppl["playerID"].astype(str)
    sal["playerID"] = sal["playerID"].astype(str)

    # Filter by year and minimum games/AB
    bat = bat[(bat["yearID"] == year) & (bat["G"] >= 70) & (bat["AB"] > 0)]
    sal_year = sal[sal["yearID"] == year]

    # === Basic Batting Metrics ===
    bat = bat.assign(
        PA=bat["AB"] + bat["BB"] + bat["HBP"] + bat.get("SF", 0),
        OBP=safe_div(bat["H"] + bat["BB"] + bat["HBP"], bat["AB"] + bat["BB"] + bat["HBP"] + bat.get("SF", 0)),
        SLG=safe_div(
            (bat["H"] - bat["2B"] - bat["3B"] - bat["HR"]) + 2*bat["2B"] + 3*bat["3B"] + 4*bat["HR"],
            bat["AB"]
        ),
        age=year - bat["playerID"].map(ppl.set_index("playerID")["birthYear"]).fillna(30)
    )

    # Fix playername mapping
    ppl_names = ppl.set_index("playerID")["nameFirst"].fillna("") + " " + ppl.set_index("playerID")["nameLast"].fillna("")
    bat["playername"] = bat["playerID"].map(ppl_names).fillna("Unknown")

    # Merge salaries
    bat = bat.merge(sal_year[["playerID", "salary"]], on="playerID", how="left").fillna({"salary": 0})

    # Merge fielding data
    fld_agg = fld.groupby("playerID", as_index=False)[["E", "InnOuts", "POS"]].agg({
        "E": "sum",
        "InnOuts": "sum",
        "POS": "first"
    })
    bat = bat.merge(fld_agg, on="playerID", how="left").fillna({"E": 0, "InnOuts": 0, "POS": "unknown"})

    # === Advanced Calculated Metrics ===
    bat["AVG"] = safe_div(bat["H"], bat["AB"])
    bat["OPS"] = bat["OBP"] + bat["SLG"]
    bat["ISO"] = bat["SLG"] - bat["AVG"]

    # BABIP calculation using Lahman 'SO' for strikeouts
    if "SO" in bat.columns:
        bat["BABIP"] = safe_div(bat["H"] - bat["HR"], bat["AB"] - bat["HR"] - bat["SO"] + bat.get("SF", 0))
    else:
        bat["BABIP"] = safe_div(bat["H"] - bat["HR"], bat["AB"] - bat["HR"] + bat.get("SF", 0))

    # Keep only the relevant columns
    keep = [
        "playerID", "playername", "teamID", "yearID", "age", "PA", "AB", "H", "HR", "BB", "SB",
        "OBP", "SLG", "AVG", "OPS", "ISO", "BABIP",
        "E", "InnOuts", "POS", "salary", "G"
    ]
    return bat[keep].drop_duplicates()



def scout_ratings(df):
    hit = scale_20_80(df["OBP"], .27, .38)
    power = scale_20_80(df["SLG"], .35, .60)
    run = scale_20_80(safe_div(df["SB"], df["PA"]), 0, .05)
    fld = scale_20_80(2.5 - safe_div(df["E"]*9, df["InnOuts"]/3), -1, 2.5)
    ovr = 0.4*hit + 0.3*power + 0.15*run + 0.15*fld
    pot = np.where(df["age"]<=27, ovr*1.05, ovr*0.95)
    df["ovr_20_80"] = ovr.round()
    df["potential_20_80"] = np.maximum(ovr, pot).round()
    return df

# ----------------------------- PITCHERS -----------------------------
def build_pitcher_df(year, paths):
    pit = load_csv_cached(paths.pitching_csv)
    ppl = load_csv_cached(paths.people_csv)
    sal = load_csv_cached(paths.salaries_csv)

    pit = pit[(pit["yearID"]==year) & (pit["IPouts"]>20)]
    sal_year = sal[sal["yearID"]==year]

    # --- ADD THIS CHECK ---

    agg = pit.groupby("playerID", as_index=False).agg({
        "IPouts":"sum","SO":"sum","BB":"sum","HR":"sum","ER":"sum","G":"sum","H":"sum","teamID":"first"
    })
    ppl_dict = ppl.set_index("playerID")[["nameFirst","nameLast","birthYear"]].to_dict("index")
    agg["playername"] = agg["playerID"].map(lambda x: f"{ppl_dict.get(x,{}).get('nameFirst','')} {ppl_dict.get(x,{}).get('nameLast','')}")
    agg["birthYear"] = agg["playerID"].map(lambda x: ppl_dict.get(x,{}).get("birthYear",1990))

    agg = agg.merge(sal_year[["playerID","salary"]], on="playerID", how="left").fillna({"salary":0})

    ip = agg["IPouts"].astype(float)/3
    agg["ERA"]= (agg["ER"]*9) / ip
    agg["WHIP"] = (agg["H"]+agg["BB"]) / ip
    def safe_div(numerator, denominator):
      return np.where(denominator>0, numerator/denominator, 0)
    agg = agg.assign(
        IP=ip,
        k_per_9=safe_div(agg["SO"]*9, ip),
        bb_per_9=safe_div(agg["BB"]*9, ip),
        hr_per_9=safe_div(agg["HR"]*9, ip),
        whip=safe_div(agg["BB"]+agg["H"], ip),
        era=safe_div(agg["ER"]*9, ip),
        age=year - agg["birthYear"],
        POS = "P",
        yearID=year

    )

    keep = ["playerID","playername","teamID","yearID","age","IP","k_per_9","bb_per_9","hr_per_9","WHIP","ERA","G","salary","POS"]
    return agg[keep].drop_duplicates()

# ----------------------------- AI MODELS -----------------------------

def train_predict_models_batters(year):
    """
    SIMPLIFIED - percentage boosts applied at prediction time only
    """
    cache = os.path.join(CACHE_DIR, f"batter_models_v4_{year}.pkl")
    if os.path.exists(cache):
        models, feats = joblib.load(cache)
        return models, feats

    hist = load_csv_cached(paths.batting_csv)
    ppl = load_csv_cached(paths.people_csv)

    hist = hist[(hist["yearID"] < year) & (hist["yearID"] >= year-5) & (hist["AB"] > 50)]
    birth_dict = ppl.set_index("playerID")["birthYear"].to_dict()
    hist["age"] = hist["yearID"] - hist["playerID"].map(birth_dict).fillna(30)

    # BASE FEATURES (no talent columns!)
    hist["PA"] = hist["AB"] + hist["BB"] + hist["HBP"] + hist.get("SF", 0)
    hist["OBP"] = safe_div(hist["H"]+hist["BB"]+hist["HBP"], hist["PA"])
    tb = (hist["H"]-hist["2B"]-hist["3B"]-hist["HR"]) + 2*hist["2B"]+3*hist["3B"]+4*hist["HR"]
    hist["SLG"] = safe_div(tb, hist["AB"])

    hist["bb_rate"] = safe_div(hist["BB"], hist["PA"])
    hist["k_rate"] = safe_div(hist["SO"], hist["PA"]) if "SO" in hist else 0.2
    hist["iso"] = hist["SLG"] - safe_div(hist["H"], hist["AB"])
    hist["recent_trend"] = hist.groupby("playerID")["OBP"].transform(lambda x: x.rolling(2, min_periods=1).mean().shift(1).fillna(x.mean()))
    hist["age_peak"] = np.maximum(30 - np.abs(hist["age"] - 27), 0.5)

    # ðŸš€ SIMPLIFIED FEATURES - NO TALENT COLUMNS
    feats = ["age", "AB", "PA", "H", "BB", "HR", "OBP", "SLG", "bb_rate", "k_rate", "iso", "age_peak", "recent_trend"]
    hist[feats] = hist[feats].fillna(0)

    if len(hist) > 10000:
        hist = hist.sample(n=10000, random_state=42)

    # Train on RAW stats (boosting happens in apply_ai_models_batters)
    from xgboost import XGBRegressor
    from sklearn.ensemble import GradientBoostingRegressor, VotingRegressor

    def train_ensemble(X, y, name):
        m1 = XGBRegressor(n_estimators=75, max_depth=5, random_state=42)
        m2 = GradientBoostingRegressor(n_estimators=75, max_depth=5, random_state=42)
        m3 = RandomForestRegressor(n_estimators=50, max_depth=6, random_state=42)
        ensemble = VotingRegressor([('xgb', m1), ('gb', m2), ('rf', m3)])
        ensemble.fit(X, y)
        return ensemble

    models = {}
    models["obp"] = train_ensemble(hist[feats], hist["OBP"], "obp")
    models["slg"] = train_ensemble(hist[feats], hist["SLG"], "slg")
    models["hr"]  = train_ensemble(hist[feats], hist["HR"], "hr")

    joblib.dump((models, feats), cache)
    return models, feats
def apply_ai_models_batters(df, models, feats):
    """Applies age-boosted predictions with FIXED randomization"""
    import numpy as np

    # === RECREATE BASE FEATURES ===
    if "PA" not in df.columns:
        df["PA"] = df["AB"] + df["BB"] + df.get("HBP", 0) + df.get("SF", 0)
    if "OBP" not in df.columns:
        df["OBP"] = safe_div(df["H"]+df["BB"]+df.get("HBP", 0), df["PA"])
    if "SLG" not in df.columns:
        tb = (df["H"] - df.get("2B", 0) - df.get("3B", 0) - df["HR"]) + \
             2*df.get("2B", 0) + 3*df.get("3B", 0) + 4*df["HR"]
        df["SLG"] = safe_div(tb, df["AB"])

    # ðŸš€ FIXED RANDOMIZED AGE FACTORS
    if "playerID" in df.columns:
        player_hash = hash(df["playerID"].iloc[0]) % 1000  # String â†’ number
        np.random.seed(42 + player_hash)
    else:
        np.random.seed(42)
    # ðŸš€ GENTLER AGE CURVE (less youth boost, kinder to veterans)
    age = df["age"].fillna(27)

    # Reduced youth boost, reduced veteran penalty
    base_obp = np.where(age <= 27, 1 + (27-age)/60, 1 - (age-27)/100)  # +6% max, -3% max
    base_slg = np.where(age <= 27, 1 + (27-age)/70, 1 - (age-27)/120)  # +5% max, -2.5% max
    base_hr  = np.where(age <= 27, 1 + (27-age)/90, 1 - (age-27)/180)  # +4% max, -1.5% max

    # Add variance (Â±4% OBP, Â±3% SLG, Â±2.5% HR)
    variance_obp = 1 + np.random.normal(0, 0.04, len(age))
    variance_slg = 1 + np.random.normal(0, 0.03, len(age))
    variance_hr  = 1 + np.random.normal(0, 0.025, len(age))

    obp_boost = base_obp * variance_obp
    slg_boost = base_slg * variance_slg
    hr_boost  = base_hr  * variance_hr

    # DISPLAY COLUMNS (% format)
    df["age_factor_obp"] = (obp_boost * 100).round(0).astype(int).astype(str) + "%"
    df["age_factor_slg"] = (slg_boost * 100).round(0).astype(int).astype(str) + "%"
    df["age_factor_hr"]  = (hr_boost * 100).round(0).astype(int).astype(str) + "%"

    # Match training features
    if "bb_rate" not in df.columns:
        df["bb_rate"] = df["BB"] / df["PA"].clip(1)
    if "k_rate" not in df.columns:
        df["k_rate"] = df.get("SO", 150) / df["PA"].clip(1)
    if "iso" not in df.columns:
        df["iso"] = df["SLG"] - (df["H"] / df["AB"].clip(1))
    if "age_peak" not in df.columns:
        df["age_peak"] = np.maximum(30 - np.abs(df["age"].fillna(27) - 27), 0.5)
    if "recent_trend" not in df.columns:
        df["recent_trend"] = df["OBP"]

    df[feats] = df[feats].fillna(0)
    X = df[feats]

    # RAW MODEL PREDICTIONS
    raw_obp = models["obp"].predict(X)
    raw_slg = models["slg"].predict(X)
    raw_hr  = models["hr"].predict(X)

    # ðŸŽ¯ APPLY BOOSTS + ELITE BONUS
    elite_obp = 1 + raw_obp * 0.4
    elite_slg = 1 + raw_slg * 0.4
    elite_hr  = 1 + raw_hr / 33

    df["pred_obp"] = np.round(raw_obp * obp_boost * elite_obp, 3).clip(0.25, 0.45)
    df["pred_slg"] = np.round(raw_slg * slg_boost * elite_slg, 3).clip(0.35, 0.55)
    df["pred_hr"] = np.round(raw_hr * hr_boost * elite_hr * 0.85).clip(0, 50)

    df["pred_obp"] = df["pred_obp"] * 0.92  # Shrink 8% (0.0364/0.0483 bias)
    df["pred_slg"] = df["pred_slg"] * 0.90  # Shrink 10% (0.0492/0.0668 bias)
    df["pred_hr"]  = df["pred_hr"]  * 0.80  # Shrink 20% (1.59/7.84 huge bias)

    # Re-clip after calibration
    df["pred_obp"] = df["pred_obp"].clip(0.25, 0.45).round(3)
    df["pred_slg"] = df["pred_slg"].clip(0.35, 0.55).round(3)
    df["pred_hr"]  = df["pred_hr"].clip(0, 40).round(0)

    # OVR (unchanged)
    if "ovr_20_80" not in df.columns:
        df["ovr_20_80"] = 50
    ovr = df["pred_obp"]*280 + df["pred_slg"]*160 + df["pred_hr"]*1.8 + df["ovr_20_80"]
    df["ovr_70_99"] = (70 + (ovr - ovr.min()) / (ovr.max() - ovr.min() + 1e-9) * 29).round()
    df["potential_70_99"] = np.minimum(df["ovr_70_99"] * 1.06, 99).round()

    return df





# ----------------------------- CONTRACTS & TEAMS -----------------------------
def project_contracts(df):
    if "ovr_70_99" not in df.columns:
        era_rating = scale_20_80(5.0 - df["ERA"].clip(1, 8), -3, 4)
        whip_rating = scale_20_80(2.0 - df["WHIP"].clip(0.8, 2.0), 0, 1.2)
        k_rating = scale_20_80(df["k_per_9"], 4, 12)
        df["ovr_70_99"] = ((era_rating + whip_rating + k_rating) / 3 * 50/80 + 50).clip(70, 99)
        df["potential_70_99"] = np.where(df["age"] <= 27, df["ovr_70_99"] * 1.05, df["ovr_70_99"]).clip(70, 99)
    value = df["ovr_70_99"] * 0.5 + df["potential_70_99"] * 0.45
    proj = 0.5e6 + (value-70) * (35e6-0.5e6) / 29
    df["contract"] = (proj/1000).round() * 1000
    return df
def team_analysis(df, year):
    teams = load_csv_cached(paths.teams_csv)
    teams = teams[teams["yearID"]==year]
    agg_dict = {"ovr_20_80":"mean","contract":"sum","playerID":"nunique",
                "pred_hr":"sum","pred_obp":"mean","pred_slg":"mean"}
    team_sum = df.groupby("teamID", as_index=False).agg(agg_dict)
    team_sum.rename(columns={"playerID":"size","ovr_20_80":"ovr",
                             "pred_hr":"hr","pred_obp":"obp","pred_slg":"slg"}, inplace=True)
    # Make sure all necessary columns exist for mapping
    teams_info = teams.set_index("teamID")[["W","L","name"]].to_dict("index")
    team_sum["record"] = team_sum["teamID"].apply(lambda t: f"{teams_info.get(t, {}).get('W',0)}-{teams_info.get(t, {}).get('L',0)}")
    team_sum["teamname"] = team_sum["teamID"].apply(lambda t: teams_info.get(t, {}).get("name","Unknown"))
    return team_sum


# ----------------------------- DASHBOARD / UI -----------------------------
def analyze_team_needs(players):
    if not players:
        return "This team has no qualified players."

    positions = {}
    pitchers = []

    for p in players:
        pos = "Pitcher" if p["POS"]=="P" else p["POS"]
        positions.setdefault(pos, []).append(p)
        if pos == "Pitcher":
            pitchers.append(p)

    needs = []

    # Position players: no 80+ OVR / 85+ potential star
    for pos, ps in positions.items():
        if pos != "Pitcher":  # Skip pitchers (handled separately)
            if not any(p["ovr_70_99"]>=80 and p["potential_70_99"]>=85 for p in ps):
                needs.append(pos)

    # Pitching staff: average pitcher quality too low
    if pitchers:
        avg_pitcher_ovr = np.mean([p["ovr_70_99"] for p in pitchers])
        avg_pitcher_pot = np.mean([p["potential_70_99"] for p in pitchers])
        if avg_pitcher_ovr < 79 or avg_pitcher_pot < 80:
            needs.append("Pitching Staff")

    if not needs:
        return "The team is strong across all positions - elite stars everywhere + quality pitching staff!"

    return f"This team needs upgrades at: {', '.join(needs)}"

def display_team_analysis(batters_dict, pitchers_dict, team_dict, team_id=None):
    import numpy as np

    # --- Fill missing predicted stats for batters ---
    for player in batters_dict:
        if "predicted_OBP" not in player:
            player["predicted_OBP"] = player.get("OBP", 0)
        if "predicted_SLG" not in player:
            player["predicted_SLG"] = player.get("SLG", 0)
        if "predicted_HR" not in player:
            player["predicted_HR"] = player.get("HR", 0)

    # --- Compute OVR for a player ---
    def compute_player_ovr(player):
        if "ovr_70_99" in player and player["ovr_70_99"] > 0:
            return player["ovr_70_99"]
        obp = player.get("predicted_OBP", 0)
        slg = player.get("predicted_SLG", 0)
        hr = player.get("predicted_HR", 0)
        return 70 + ((obp*250 + slg*150 + hr*2)) / 5  # adjust scaling if needed

    # --- Combine all players and identify hitters ---
    all_players = batters_dict + pitchers_dict
    hitters = [p for p in batters_dict if p.get("POS", "P") != "P"]

    # --- Display selected team ---
    if team_id:
        team_players = [p for p in all_players if p["teamID"] == team_id]
        team_hitters = [p for p in hitters if p["teamID"] == team_id]
        team_info = next((t for t in team_dict if t["teamID"] == team_id), None)

        if team_info:
            avg_ovr = np.mean([compute_player_ovr(p) for p in team_players])
            avg_obp = np.mean([p["predicted_OBP"] for p in team_hitters]) if team_hitters else 0
            avg_slg = np.mean([p["predicted_SLG"] for p in team_hitters]) if team_hitters else 0
            total_hr = sum([p.get("predicted_HR", 0) for p in team_hitters])
            payroll = team_info.get("payroll", sum(p.get("contract", 0) for p in team_players))
            roster_size = len(team_players)
            cap_status = "UNDER the cap âœ…" if payroll <= SALARY_CAP else "OVER the cap ðŸš¨"

            # --- Top table ---
            print(f"\n{'='*100}\nðŸ“Š {team_info['teamname']} ({team_info.get('record','')})\n{'='*100}")
            print(f"{'teamID':<6} {'ovr':<6} {'contract':<15} {'size':<5} {'hr':<5} {'obp':<6} {'slg':<6} {'record':<8} {'teamname'}")
            print(f"{team_id:<6} {avg_ovr:<6.2f} {format_money(payroll):<15} {roster_size:<5} {total_hr:<5} {avg_obp:.3f} {avg_slg:.3f} {team_info.get('record',''):<8} {team_info.get('teamname','')}")

            print(f"\nTeam Assessment: {analyze_team_needs(team_players)}\n")
        else:
            print(f"Team {team_id} not found")

    # --- League summary (bottom table) ---
    else:
        print("\n" + "="*120)
        print("ðŸŒŽ LEAGUE TEAM NEEDS SUMMARY")
        print("="*120)
        print(f"{'Team':<25} {'Record':<8} {'Payroll':<12} {'Cap Status':<15} {'Avg OVR':<8} {'Assessment'}")
        print("-"*120)
        for t in team_dict:
            team_players = [p for p in all_players if p["teamID"] == t["teamID"]]
            needs = analyze_team_needs(team_players)
            payroll = t.get("payroll", sum(p.get("contract",0) for p in team_players))
            cap_status = "Under Cap" if payroll <= SALARY_CAP else "Over Cap"
            avg_ovr = np.mean([compute_player_ovr(p) for p in team_players])
            print(f"{t['teamname'][:24]:<25} {t['record']:<8} {format_money(payroll):<12} {cap_status:<15} {avg_ovr:<8.1f} {needs}")






from ipywidgets import interact, Dropdown
from IPython.display import display



# ----------------------------- INTERACTIVE DASHBOARD (FIXED) -----------------------------
def interactive_team_players_full(batters, pitchers, teams):
    """Dropdown to select a team and view all player stats, including real, calculated, and predicted."""
    import ipywidgets as widgets
    from IPython.display import display

    all_players = pd.DataFrame(batters + pitchers)

    # Fill missing POS / numeric columns
    all_players["POS"] = all_players["POS"].fillna("??").str.upper()
    all_players["salary"] = all_players["salary"].clip(lower=500_000)
    numeric_cols = ["age", "G", "PA", "AB", "H", "HR", "BB", "SB",
                    "OBP", "SLG", "AVG", "OPS", "ISO", "BABIP",
                    "E",
                    "pred_obp", "pred_slg", "pred_hr"]
    for col in numeric_cols:
        if col in all_players.columns:
            all_players[col] = all_players[col].fillna(0)
        else:
            all_players[col] = 0

    # Dropdown options
    options = [(f"{t['teamname']} ({t['teamID']})", t['teamID']) for t in teams]
    team_dropdown = widgets.Dropdown(options=options, description="Select Team:", style={'description_width': 'initial'})
    display(team_dropdown)

    def on_team_change(change):
        if change['type'] == 'change' and change['name'] == 'value':
            team_id = change['new']
            df_team = all_players[all_players["teamID"] == team_id].copy()
            if df_team.empty:
                print("No players for this team.")
                return

            # Show all relevant stats
            cols = ["playername", "POS", "age", "G", "PA", "AB", "H", "HR", "BB", "SB",
                    "OBP", "SLG", "AVG", "OPS", "ISO", "BABIP",
                    "pred_obp", "pred_slg", "pred_hr",
                    "E", "salary"]

            df_team_show = df_team[cols].sort_values("OPS", ascending=False).reset_index(drop=True)
            df_team_show["salary"] = df_team_show["salary"].apply(lambda x: f"${x:,.0f}")

            print(f"\nAll Players for Team {team_id}:")
            display(df_team_show)

            # Optional: separate batters and pitchers
            df_batters = df_team_show[df_team_show["POS"] != "P"]
            if not df_batters.empty:
                print("\nBatters:")
                display(df_batters)
            df_pitchers = df_team_show[df_team_show["POS"] == "P"]
            if not df_pitchers.empty:
                print("\nPitchers:")
                display(df_pitchers)

    team_dropdown.observe(on_team_change)
def interactive_team_players_separate(batters, pitchers, teams, team_summary):
    import ipywidgets as widgets
    from IPython.display import display, clear_output
    import pandas as pd
    import numpy as np

    df_batters = pd.DataFrame(batters).copy()
    df_pitchers = pd.DataFrame(pitchers).copy()
    df_summary = pd.DataFrame(team_summary).copy()

    # Ensure POS exists
    df_batters["POS"] = df_batters.get("POS", "??").fillna("??").str.upper()
    df_pitchers["POS"] = "P"

    # Fill numeric columns safely
    bat_numeric = ["age","G","PA","AB","H","HR","BB","SB","OBP","SLG","AVG",
                   "BABIP","ovr_70_99","potential_70_99","contract",
                   "predicted_OBP","predicted_SLG","predicted_HR"]
    pit_numeric = ["age","G","IP","ERA","WHIP","k_per_9","bb_per_9","hr_per_9",
                   "ovr_70_99","potential_70_99","contract"]

    for col in bat_numeric:
        if col not in df_batters.columns:
            df_batters[col] = 0
        else:
            df_batters[col] = pd.to_numeric(df_batters[col], errors='coerce').fillna(0)

    for col in pit_numeric:
        if col not in df_pitchers.columns:
            df_pitchers[col] = 0
        else:
            df_pitchers[col] = pd.to_numeric(df_pitchers[col], errors='coerce').fillna(0)

    # Round pitcher OVR and potential to nearest whole numbers
    df_pitchers["ovr_70_99"] = df_pitchers["ovr_70_99"].round(0).astype(int)
    df_pitchers["potential_70_99"] = df_pitchers["potential_70_99"].round(0).astype(int)

    # Show ALL columns globally
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', None)

    # Dropdown
    options = [(f"{t['teamname']} ({t['teamID']})", t['teamID']) for t in teams]
    team_dropdown = widgets.Dropdown(options=options, description="Select Team:", style={'description_width': 'initial'})
    display(team_dropdown)

    output = widgets.Output()
    display(output)

    def on_team_change(change):
        if change['type'] == 'change' and change['name'] == 'value':
            team_id = change['new']
            with output:
                clear_output(wait=True)

                # ---------- TEAM SUMMARY ----------
                df_team_summary = df_summary[df_summary["teamID"] == team_id].copy()
                if not df_team_summary.empty:
                    # Qualified batters (for averages in summary)
                    qualified_batters = df_batters[
                        (df_batters["teamID"] == team_id) & (df_batters["PA"] >= 100)
                    ]

                    # Qualified pitchers
                    qualified_pitchers = df_pitchers[
                        (df_pitchers["teamID"] == team_id) & (df_pitchers["IP"] >= 40)
                    ]

                    #  AVG OVR + POTENTIAL FROM ALL QUALIFIED PLAYERS
                    all_qualified = pd.concat(
                        [qualified_batters, qualified_pitchers], ignore_index=True
                    )
                    if not all_qualified.empty:
                        avg_ovr = round(all_qualified["ovr_70_99"].mean(), 1)
                        avg_potential = round(all_qualified["potential_70_99"].mean(), 0).astype(int)
                        df_team_summary["ovr"] = avg_ovr
                        df_team_summary["avg_potential"] = avg_potential

                    # hitter-only averages for OBP, SLG, AVG
                    if not qualified_batters.empty:
                        avg_obp = qualified_batters["OBP"].mean()
                        avg_slg = qualified_batters["SLG"].mean()
                        avg_avg = qualified_batters["AVG"].mean()

                        df_team_summary["avg_OBP"] = avg_obp.round(3)
                        df_team_summary["avg_SLG"] = avg_slg.round(3)
                        df_team_summary["avg_AVG"] = avg_avg.round(3)
                    else:
                        df_team_summary["avg_OBP"] = np.nan.round(3)
                        df_team_summary["avg_SLG"] = np.nan.round(3)
                        df_team_summary["avg_AVG"] = np.nan.round(3)
                    df_team_summary = df_team_summary.drop(
                        columns=[c for c in ["obp", "slg", "AVG"] if c in df_team_summary.columns],
                        errors="ignore"
                    )
                    display(
                        df_team_summary.style.set_caption(
                            f"ðŸ“ˆ Summary for Team {team_id}"
                        )
                    )
                else:
                    print("\nNo summary data for this team.")

                # ---------- BATTERS TABLE (unchanged) ----------
                df_team_batters = df_batters[df_batters["teamID"] == team_id].copy()
                qualified_batters = df_team_batters[df_team_batters["PA"] >= 100]
                if not qualified_batters.empty:
                    print(f"\nðŸ“Š Batters for Team {team_id}:")

                    # Remove unwanted columns
                    drop_cols = ["playerID", "PA", "ISO", "E", "salary", "bb_rate", "k_rate", "InnOuts",
                                "pred_obp", "pred_slg", "pred_hr"]
                    df_show = qualified_batters.drop(columns=[c for c in drop_cols if c in qualified_batters.columns])
                    df_show = df_show.sort_values("ovr_70_99", ascending=False).reset_index(drop=True)

                    # Format money columns only
                    money_cols = ["contract"]
                    for col in money_cols:
                        if col in df_show.columns:
                            df_show[col] = df_show[col].apply(lambda x: f"${x:,.0f}")

                    # Auto-round decimals
                    for col in df_show.select_dtypes(include=[np.number]).columns:
                        if col not in money_cols:
                            df_show[col] = df_show[col].round(3)

                    display(df_show)
                else:
                    print("\nNo batters for this team.")

                # ---------- PITCHERS TABLE (unchanged) ----------
                df_team_pitchers = df_pitchers[df_pitchers["teamID"] == team_id].copy()
                qualified_pitchers = df_team_pitchers[df_pitchers["IP"] >= 40]
                if not qualified_pitchers.empty:
                    print(f"\nðŸ“Š Pitchers for Team {team_id}:")

                    # Remove unwanted columns
                    drop_cols = ["playerID","teamID", "salary", "pred_obp", "pred_slg", "pred_hr",
                                "predicted_OBP", "predicted_SLG", "predicted_HR"]
                    df_show = qualified_pitchers.drop(columns=[c for c in drop_cols if c in qualified_pitchers.columns])
                    df_show = df_show.sort_values("ovr_70_99", ascending=False).reset_index(drop=True)

                    # Format money columns
                    money_cols = ["contract"]
                    for col in money_cols:
                        if col in df_show.columns:
                            df_show[col] = df_show[col].apply(lambda x: f"${x:,.0f}")

                    # Auto-round decimals
                    for col in df_show.select_dtypes(include=[np.number]).columns:
                        if col not in money_cols:
                            df_show[col] = df_show[col].round(3)

                    display(df_show)
                else:
                    print("\nNo pitchers for this team.")

    team_dropdown.observe(on_team_change)






def interactive_team_analysis(batters_dict, pitchers_dict, team_dict):
    """Create a dropdown to select a team and show detailed analysis"""
    # Build dropdown options: show full team name with teamID
    options = [(f"{t['teamname']} ({t['teamID']})", t['teamID']) for t in team_dict]

    @interact(team=Dropdown(options=options, description="Select Team:", style={'description_width': 'initial'}))
    def show_team(team):
        display_team_analysis(batters_dict, pitchers_dict, team_dict, team_id=team)
def show_contracts_with_predicted_stats(df_batting, df_people, df_fielding, df_salaries, year):
    """
    Combine MLB player stats, salary data, and predicted performance metrics.
    Includes both batters and pitchers, predicted OBP (on-base probability),
    stat deviations, and a minimum contract floor of $500,000.
    """

    # --- AGE CALCULATION ---
    df_people_age = df_people.copy()
    df_people_age["Age"] = year - df_people_age["birthYear"]

    # --- MERGE DATASETS ---
    df = df_batting.merge(df_people_age, on="playerID", how="left")
    df = df.merge(df_salaries[df_salaries["yearID"] == year], on="playerID", how="left")

    # --- SALARY FIX ---
    df["salary"] = df["salary"].fillna(500_000)
    df.loc[df["salary"] == 0, "salary"] = 500_000

    # --- PREDICTED STATS (simplified regression proxy) ---
    # Based on userâ€™s model idea: "getting on base" using OBP, hits, and quality of at-bats
    # OBP = (H + BB + HBP) / (AB + BB + HBP + SF)
    df["OBP"] = (
        (df["H"] + df.get("BB", 0) + df.get("HBP", 0))
        / (df["AB"] + df.get("BB", 0) + df.get("HBP", 0) + df.get("SF", 0))
    ).round(3)

    # Predicted "On Base Performance" score using regression-style weighting
    df["Predicted_OBP"] = (
        0.55 * df["OBP"] +
        0.25 * (df["H"] / df["AB"].replace(0, 1)) +
        0.20 * (df.get("QAB", 0) / df.get("PA", 1))  # Quality at-bats per plate appearance
    ).round(3)

    # Predicted WAR as a composite (example, can link to real regression later)
    df["Predicted_WAR"] = (
        0.003 * df["R"] + 0.005 * df["HR"] + 0.0025 * df["RBI"]
    ).round(2)

    # --- DEVIATIONS (League Average Context) ---
    league_avg_obp = df["Predicted_OBP"].mean()
    league_avg_war = df["Predicted_WAR"].mean()
    df["OBP_Deviation"] = (df["Predicted_OBP"] - league_avg_obp).round(3)
    df["WAR_Deviation"] = (df["Predicted_WAR"] - league_avg_war).round(2)

    # --- SORT ---
    df = df.sort_values("salary", ascending=False)

    # --- RETURN CORE COLUMNS ---
    return df[
        [
            "playerID",
            "nameFirst",
            "nameLast",
            "Age",
            "teamID",
            "POS",
            "salary",
            "OBP",
            "Predicted_OBP",
            "OBP_Deviation",
            "Predicted_WAR",
            "WAR_Deviation",
        ]
    ]
def fill_predicted_batter_stats(batters_list, models, feats):
    """
    Fill predicted OBP, SLG, and HR for each batter in a list of dictionaries.
    Rounds OBP and SLG to 3 decimal places, HR to nearest whole number.
    Updates the list in place.
    """
    import pandas as pd
    import numpy as np

    df = pd.DataFrame(batters_list)

    # Ensure all feature columns exist
    for col in feats:
        if col not in df.columns:
            df[col] = 0

    # Apply AI models
    df = apply_ai_models_batters(df, models, feats)

    # Rename prediction columns for dashboard consistency
    df.rename(columns={
        "pred_obp": "predicted_OBP",
        "pred_slg": "predicted_SLG",
        "pred_hr": "predicted_HR"
    }, inplace=True)

    # Round predictions
    df["predicted_OBP"] = df["predicted_OBP"].round(3)
    df["predicted_SLG"] = df["predicted_SLG"].round(3)
    df["predicted_HR"] = df["predicted_HR"].round(0).astype(int)

    # Update original list in place
    batters_list[:] = df.to_dict(orient="records")





# ===================================================
# ================= STREAMLIT UI ====================
# ===================================================
def main():
    st.set_page_config(page_title="MLB Contracts & Predicted Stats", layout="wide")

    st.title("âš¾ MLB Player Contracts & Predicted Performance")

    # File uploaders
    st.sidebar.header("Upload CSV Data")
    df_batting = st.sidebar.file_uploader("Batting Data", type="csv")
    df_people = st.sidebar.file_uploader("People Data", type="csv")
    df_fielding = st.sidebar.file_uploader("Fielding Data", type="csv")
    df_salaries = st.sidebar.file_uploader("Salaries Data", type="csv")
    year = st.sidebar.number_input("Season Year", min_value=2000, max_value=2025, value=2023)

    if all([df_batting, df_people, df_fielding, df_salaries]):
        df_batting = pd.read_csv(df_batting)
        df_people = pd.read_csv(df_people)
        df_fielding = pd.read_csv(df_fielding)
        df_salaries = pd.read_csv(df_salaries)

        contracts_df = show_contracts_with_predicted_stats(
            df_batting, df_people, df_fielding, df_salaries, year
        )

        st.success("âœ… Data processed successfully!")

        # --- Player dropdown (now includes both batters & pitchers) ---
        contracts_df["FullName"] = contracts_df["nameFirst"] + " " + contracts_df["nameLast"]
        player_name = st.selectbox("Select a Player", sorted(contracts_df["FullName"].unique()))

        selected = contracts_df[contracts_df["FullName"] == player_name].iloc[0]

        # --- PLAYER CARD ---
        st.subheader(f"{selected['FullName']} ({selected['teamID']})")
        col1, col2, col3 = st.columns(3)
        col1.metric("Age", int(selected["Age"]))
        col2.metric("Salary", f"${selected['salary']:,.0f}")
        col3.metric("Position", selected["POS"])

        st.markdown("---")

        col1, col2 = st.columns(2)
        with col1:
            st.markdown("### ðŸ“ˆ Predicted Performance")
            st.write(f"**OBP:** {selected['OBP']}")
            st.write(f"**Predicted OBP:** {selected['Predicted_OBP']}")
            st.write(f"**OBP Deviation:** {selected['OBP_Deviation']:+}")
            st.write(f"**Predicted WAR:** {selected['Predicted_WAR']}")
            st.write(f"**WAR Deviation:** {selected['WAR_Deviation']:+}")

        with col2:
            st.markdown("### ðŸ’° Contract Overview")
            st.write(f"**Adjusted Salary:** ${selected['salary']:,.0f}")
            if selected["salary"] == 500_000:
                st.caption("(*Contract value auto-set to minimum $500K*)")

        # --- Optional: Show full dataset ---
        st.markdown("---")
        st.markdown("### Full Player Data")
        st.dataframe(contracts_df.reset_index(drop=True), use_container_width=True)

    else:
        st.info("ðŸ‘ˆ Upload all four CSV files to begin.")

# ----------------------------- MAIN EXECUTION -----------------------------
import ipywidgets as widgets
from IPython.display import display, clear_output  # âœ… Added clear_output here

# Create year dropdown (2010-2023 range, default 2019)
year_options = list(range(1950, 2024))
year_dropdown = widgets.Dropdown(
    options=year_options,
    value=2019,
    description='Select Year:',
    style={'description_width': 'initial'}
)

# Output widget for results
output = widgets.Output()
display(year_dropdown, output)

def run_analysis(change):
    import pandas as pd
    import numpy as np
    with output:
        clear_output(wait=True)
        print(f"ðŸ”„ Processing {change['new']} season data...")

        year = change['new']

        # BUILD BATTERS DATAFRAME
        batters = build_batter_df(year, paths)
        batters = scout_ratings(batters)

        # TRAIN AND APPLY AI MODELS FOR BATTERS
        b_models, b_feats = train_predict_models_batters(year)
        batters = apply_ai_models_batters(batters, b_models, b_feats)

        # === KEEP LOWERCASE PREDICTED COLUMNS FOR TEAM ANALYSIS COMPATIBILITY
        # Create capitalized duplicates for display
        batters["predicted_OBP"] = batters["pred_obp"]
        batters["predicted_SLG"] = batters["pred_slg"]
        batters["predicted_HR"] = batters["pred_hr"]

        # PROJECT CONTRACTS FOR BATTERS
        batters = project_contracts(batters)
        batters["contract"] = batters["contract"].clip(lower=500_000)
        batters["POS"] = batters["POS"].fillna("??").str.upper()

        # BUILD PITCHERS DATAFRAME
        pitchers = build_pitcher_df(year, paths)
        pitchers = project_contracts(pitchers)
        pitchers["contract"] = pitchers["contract"].clip(lower=500_000)
        pitchers["POS"] = "P"

        # Add lowercase predicted columns as zeros for pitchers (compatibility)
        pitchers["pred_obp"] = 0.0
        pitchers["pred_slg"] = 0.0
        pitchers["pred_hr"] = 0

        # Add capitalized predicted columns for display
        pitchers["predicted_OBP"] = 0.0
        pitchers["predicted_SLG"] = 0.0
        pitchers["predicted_HR"] = 0

        # COMBINE ALL PLAYERS FOR TEAM ANALYSIS (keep lowercase columns)
        all_players = pd.concat([batters, pitchers], ignore_index=True)

        # Now call team analysis which expects lowercase predicted columns
        team_summary = team_analysis(all_players, year)
        dashboard_teams = team_summary.to_dict("records")

        print(f"âœ… {year} season analysis complete!")
        print(f"Batters: {len(batters)}, Pitchers: {len(pitchers)}, Teams: {len(team_summary)}")

        # Create dashboard dicts for display (including capitalized cols)
        dashboard_batters = batters.to_dict("records")
        dashboard_pitchers = pitchers.to_dict("records")

        # Show interactive dashboard
        interactive_team_players_separate(
            dashboard_batters, dashboard_pitchers, dashboard_teams, dashboard_teams
        )

        # Show full league summary
        display_team_analysis(dashboard_batters, dashboard_pitchers, dashboard_teams)



# Run analysis when year changes
year_dropdown.observe(run_analysis, names='value')

# Run initial analysis
run_analysis({'new': 2019})

def analyze_prediction_accuracy(year, paths):
    """
    Analyzes prediction accuracy by comparing AI predictions to actual next-season performance.
    """
    import pandas as pd
    import numpy as np
    from IPython.display import display

    print(f"ðŸ” Analyzing prediction accuracy for {year} â†’ {year+1} season...")

    # Load current year data (predictions made)
    current_batters = build_batter_df(year, paths)
    current_batters = scout_ratings(current_batters)
    b_models, b_feats = train_predict_models_batters(year)
    current_batters = apply_ai_models_batters(current_batters, b_models, b_feats)

    # Load NEXT year data (actual performance)
    next_batters = build_batter_df(year + 1, paths)
    next_batters = scout_ratings(next_batters)

    print(f"Current year players: {len(current_batters)}")
    print(f"Next year players: {len(next_batters)}")

    # Merge on playerID to compare same players
    merged = current_batters.merge(
        next_batters[['playerID', 'PA', 'OBP', 'SLG', 'HR']],
        on='playerID',
        how='inner',
        suffixes=('_predicted', '_actual')
    )

    print(f"Merged players: {len(merged)}")

    # FIXED: Use LOWER PA threshold + lowercase prediction columns
    pa_threshold = 40 if year == 2019 else 100  # Lower for COVID year
    qualified = merged[
        (merged['PA_predicted'] >= pa_threshold) &
        (merged['PA_actual'] >= pa_threshold)
    ].copy()

    print(f"Qualified ({pa_threshold}+ PA both): {len(qualified)}")

    if qualified.empty:
        print("âŒ No players with sufficient PA in both seasons.")
        return

    # FIXED: Use lowercase pred_* columns from apply_ai_models_batters
    qualified['OBP_Deviation'] = qualified['pred_obp'] - qualified['OBP_actual']
    qualified['SLG_Deviation'] = qualified['pred_slg'] - qualified['SLG_actual']
    qualified['HR_Deviation'] = qualified['pred_hr'] - qualified['HR_actual']


    # Calculate absolute deviations (prediction error)
    qualified['OBP_Error'] = np.abs(qualified['OBP_Deviation'])
    qualified['SLG_Error'] = np.abs(qualified['SLG_Deviation'])
    qualified['HR_Error'] = np.abs(qualified['HR_Deviation'])
    qualified['Total_Error'] = (qualified['OBP_Error'] * 12 + qualified['SLG_Error'] * 12 +  qualified['HR_Error'] * 0.5)
    # Ensure OVR exists (fallback if missing)
    if 'ovr_70_99' not in qualified.columns:
        qualified['ovr_70_99'] = 70  # default

    # === LEAGUE-WIDE AVERAGE DEVIATIONS ===
    avg_deviations = {
        'Metric': ['OBP', 'SLG', 'HR', 'Total_Error'],
        'Avg_Deviation': [
            qualified['OBP_Deviation'].mean(),
            qualified['SLG_Deviation'].mean(),
            qualified['HR_Deviation'].mean(),
            qualified['Total_Error'].mean()
        ],
        'Avg_Abs_Error': [
            qualified['OBP_Error'].mean(),
            qualified['SLG_Error'].mean(),
            qualified['HR_Error'].mean(),
            qualified['Total_Error'].mean()
        ],
        'Over/Under': [
            'Over' if qualified['OBP_Deviation'].mean() > 0 else 'Under',
            'Over' if qualified['SLG_Deviation'].mean() > 0 else 'Under',
            'Over' if qualified['HR_Deviation'].mean() > 0 else 'Under',
            '-'
        ]
    }

    deviations_df = pd.DataFrame(avg_deviations)
    deviations_df['Avg_Abs_Error'] = deviations_df['Avg_Abs_Error'].round(4)
    deviations_df['Avg_Deviation'] = deviations_df['Avg_Deviation'].round(4)


    print("\n" + "="*80)
    print("ðŸ“Š LEAGUE-WIDE PREDICTION ACCURACY")
    print("="*80)
    display(deviations_df.reset_index(drop=True))

    # === TOP 10 HIGHEST OVR PLAYERS ===
    qualified['Total_Error'] = (qualified['OBP_Error'] * 12 +
                               qualified['SLG_Error'] * 12 +
                               qualified['HR_Error'] * 0.5)
    top_ovr = qualified.nlargest(10, 'ovr_70_99')[
        ['playername', 'teamID', 'ovr_70_99', 'OBP_Error', 'SLG_Error', 'HR_Error', 'Total_Error']
    ].round(4).reset_index(drop=True)
    print("\nâ­ TOP 10 HIGHEST OVR PLAYERS")
    display(top_ovr)

    # === TOP 10 MOST ACCURATE PREDICTIONS (weighted error) ===
    top_accurate = qualified.nsmallest(10, 'Total_Error')[
        ['playername', 'teamID', 'ovr_70_99', 'OBP_Error', 'SLG_Error', 'HR_Error', 'Total_Error']
    ].round(4).reset_index(drop=True)
    print("\nðŸ† TOP 10 MOST ACCURATE PREDICTIONS (Weighted: OBP/SLGÃ—12, HRÃ·2)")
    display(top_accurate)

    # === TOP 10 WORST PREDICTIONS ===
    top_errors = qualified.nlargest(10, 'Total_Error')[
        ['playername', 'teamID', 'ovr_70_99', 'OBP_Error', 'SLG_Error', 'HR_Error', 'Total_Error']
    ].round(4).reset_index(drop=True)
    print("\nðŸ’¥ TOP 10 WORST PREDICTIONS")
    display(top_errors)

    return qualified, deviations_df

# === PREDICTION ACCURACY UI (NEW CELL) ===
def create_accuracy_dropdown():
    from ipywidgets import Dropdown, Button, VBox, Output
    from IPython.display import display, clear_output

    accuracy_year_dropdown = Dropdown(
        options=list(range(1950, 2024)),
        value=2019,
        description='Accuracy Year:',
        style={'description_width': 'initial'}
    )

    accuracy_output = Output()
    accuracy_button = Button(
        description="ðŸ” Run Accuracy Analysis",
        button_style="success",
        layout={'width': '250px'}
    )

    def run_accuracy_analysis(b):
        with accuracy_output:
            clear_output(wait=True)
            year = accuracy_year_dropdown.value
            print(f"ðŸ” Analyzing predictions from {year} â†’ {year+1}...")
            results = analyze_prediction_accuracy(year, paths)
            if results:
                print(f"âœ… {year} analysis complete!")

    accuracy_button.on_click(run_accuracy_analysis)
    display(VBox([accuracy_year_dropdown, accuracy_button, accuracy_output]))

# CREATE THE DROPDOWN
create_accuracy_dropdown()

def analyze_prediction_accuracy_silent(year, paths):
    """Silent version - no prints/displays, just returns qualified df"""
    import pandas as pd
    import numpy as np

    current_batters = build_batter_df(year, paths)
    current_batters = scout_ratings(current_batters)
    b_models, b_feats = train_predict_models_batters(year)
    current_batters = apply_ai_models_batters(current_batters, b_models, b_feats)

    next_batters = build_batter_df(year + 1, paths)
    next_batters = scout_ratings(next_batters)

    merged = current_batters.merge(
        next_batters[['playerID', 'PA', 'OBP', 'SLG', 'HR']],
        on='playerID', how='inner', suffixes=('_predicted', '_actual')
    )

    pa_threshold = 40 if year == 2019 else 100
    qualified = merged[
        (merged['PA_predicted'] >= pa_threshold) &
        (merged['PA_actual'] >= pa_threshold)
    ].copy()

    if qualified.empty:
        return None

    qualified['OBP_Deviation'] = qualified['pred_obp'] - qualified['OBP_actual']
    qualified['SLG_Deviation'] = qualified['pred_slg'] - qualified['SLG_actual']
    qualified['HR_Deviation'] = qualified['pred_hr'] - qualified['HR_actual']

    qualified['OBP_Error'] = np.abs(qualified['OBP_Deviation'])
    qualified['SLG_Error'] = np.abs(qualified['SLG_Deviation'])
    qualified['HR_Error'] = np.abs(qualified['HR_Deviation'])
    qualified['Total_Error'] = (qualified['OBP_Error'] * 12 +
                               qualified['SLG_Error'] * 12 +
                               qualified['HR_Error'] * 0.5)

    if 'ovr_70_99' not in qualified.columns:
        qualified['ovr_70_99'] = 70

    return qualified

def plot_avg_total_error_by_season(paths, start_year=1950, end_year=2024):
    """
    YOUR ORIGINAL + COLOR DOTS (Black=3Under, Red=2Under, Blue=1Under, Green=0Under)
    """
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    from IPython.display import clear_output

    years = range(start_year, end_year)
    avg_errors = []
    under_counts = []  # ðŸ‘ˆ NEW

    print(f"âš¡ Fast analysis {start_year}-{end_year}...")

    for year in years:
        try:
            qualified = analyze_prediction_accuracy_silent(year, paths)
            if qualified is not None and not qualified.empty:
                avg_error = qualified['Total_Error'].mean()
                avg_errors.append(avg_error)

                # ðŸ‘ˆ FIXED: Metric-level under-projection (>50% players under)
                n_players = len(qualified)
                obp_under_pct = (qualified['OBP_Deviation'] < 0).mean() * 100
                slg_under_pct = (qualified['SLG_Deviation'] < 0).mean() * 100
                hr_under_pct  = (qualified['HR_Deviation'] < 0).mean() * 100

                under_metrics = sum([obp_under_pct > 50, slg_under_pct > 50, hr_under_pct > 50])
                under_counts.append(under_metrics)
            else:
                avg_errors.append(np.nan)
                under_counts.append(0)
        except:
            avg_errors.append(np.nan)
            under_counts.append(0)

    # ðŸ‘ˆ NEW: Color mapping
    colors = ['black' if c==3 else 'red' if c==2 else 'blue' if c==1 else 'green'
              for c in under_counts]

    # YOUR ORIGINAL PLOT + COLORS
    plt.figure(figsize=(12, 6))
    plt.scatter(years, avg_errors, c=colors, s=80, alpha=0.8, edgecolors='black', linewidth=1)  # ðŸ‘ˆ CHANGED
    plt.plot(years, avg_errors, color='#1f77b4', linewidth=1.5, alpha=0.6)  # ðŸ‘ˆ Line behind dots

    plt.title('Average Total Prediction Error by Season\n(Black=Overperforming, Red=Slightly Overperforming, Blue=Slightly Underperforming, Green=Underperforming)',
              fontsize=16, fontweight='bold')
    plt.xlabel('Season (Prediction Year â†’ Next Year)', fontsize=12)
    plt.ylabel('Avg Total Error (Weighted)', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.xticks(years[::2])

    # YOUR ORIGINAL trend line
    valid_data = pd.DataFrame({'Year': years, 'Error': avg_errors}).dropna()
    if len(valid_data) > 2:
        z = np.polyfit(valid_data['Year'], valid_data['Error'], 1)
        p = np.poly1d(z)
        plt.plot(valid_data['Year'], p(valid_data['Year']), "r--", alpha=0.8, linewidth=2)

    plt.tight_layout()
    plt.ylim(0, 10)
    plt.show()

    print(f"âœ… Complete! Best: {min([x for x in avg_errors if not np.isnan(x)]):.4f}")
    return pd.DataFrame({'Year': years, 'Avg_Total_Error': avg_errors, 'Under_Count': under_counts})

plot_avg_total_error_by_season(paths)

"""Functions below are in progress:"""

def calculate_pitcher_ovr(df):
    """PITCHER-SPECIFIC OVR + Age-Peaking Potential"""
    import pandas as pd
    import numpy as np

    df = df.copy()

    # Safe pitcher columns only
    numeric_cols = ['age', 'IP', 'G', 'ERA', 'WHIP', 'k_per_9', 'bb_per_9', 'hr_per_9']
    for col in numeric_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

    # Pitcher OVR formula (current ability)
    df['ovr_70_99'] = 70  # Base

    if 'ERA' in df.columns:
        df['ovr_70_99'] += np.clip(100 - df['ERA'] * 30, 0, 20)
    if 'WHIP' in df.columns:
        df['ovr_70_99'] += np.clip(140 - df['WHIP'] * 145, 0, 15)
    if 'k_per_9' in df.columns:
        df['ovr_70_99'] += np.clip(df['k_per_9'] / 2.5, 0, 10)

    # Age adjustment for CURRENT OVR
    if 'age' in df.columns:
        df['age_factor'] = np.clip(1 - (df['age'] - 27)**2 / 100, 0.8, 1.1)
        df['ovr_70_99'] *= df['age_factor']

    # ðŸ‘ˆ NEW POTENTIAL: Peaks at 27, converges to OVR after peak
    if 'age' in df.columns:
        age = df['age']

        # Peak potential boost (max at age 27)
        peak_age = 27
        potential_boost = np.clip(1.15 - np.abs(age - peak_age) * 0.02, 1.0, 1.25)

        # After peak (age 30+), potential = OVR (no upside)
        convergence_age = 30
        convergence_factor = np.clip((age - convergence_age) / 10, 0, 1)

        # Final potential formula
        df['potential_70_99'] = df['ovr_70_99'] * potential_boost * (1 - convergence_factor) + df['ovr_70_99'] * convergence_factor

    else:
        df['potential_70_99'] = df['ovr_70_99']

    # Round and clip
    df['ovr_70_99'] = df['ovr_70_99'].round().clip(70, 99).astype(int)
    df['potential_70_99'] = df['potential_70_99'].round().clip(70, 99).astype(int)

    return df


def interactive_career_progress(paths, start_year=1980, end_year=2025):
    """
    COMPLETE: Batters + Pitchers (Pitcher OVR from scratch!)
    """
    import ipywidgets as widgets
    from IPython.display import display, clear_output
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt

    player_careers = {}

    year_dropdown = widgets.Dropdown(options=[(f"{y}", y) for y in range(2000, end_year+1)], value=2020, description="Select Year:")
    player_type = widgets.ToggleButtons(options=[('Batters âš¾', 'batter'), ('Pitchers âš¾ï¸', 'pitcher'), ('Both ðŸŽ¯', 'both')], value='batter', description='Player Type:')
    player_search = widgets.Text(value='', placeholder='Type to filter...', description='Search:')
    player_dropdown = widgets.Dropdown(options=[], description="All Players:", disabled=True)
    output = widgets.Output()

    def safe_numeric(col):
        if pd.isna(col) or col is None: return 0
        try:
            if hasattr(col, 'fillna'): return pd.to_numeric(col, errors='coerce').fillna(0)
            return float(pd.to_numeric(col, errors='coerce') or 0)
        except: return 0

    def load_year_players(change=None):
        year = year_dropdown.value
        ptype = player_type.value

        with output:
            clear_output(wait=True)
            print(f"ðŸ” Loading ALL {year} {ptype}s...")

        qualified_batters = pd.DataFrame()
        qualified_pitchers = pd.DataFrame()

        try:
            # BATTERS
            if ptype in ['batter', 'both']:
                batter_df = build_batter_df(year, paths)
                if not batter_df.empty:
                    batter_df = scout_ratings(batter_df)
                    b_models, b_feats = train_predict_models_batters(year)
                    batter_df = apply_ai_models_batters(batter_df, b_models, b_feats)

                    batter_df['age'] = batter_df['age'].apply(safe_numeric)
                    batter_df['PA'] = batter_df['PA'].apply(safe_numeric)
                    batter_df['ovr_70_99'] = batter_df['ovr_70_99'].apply(safe_numeric)

                    qualified_batters = batter_df[(batter_df['PA'] >= 100) & (batter_df['ovr_70_99'] > 0)].sort_values('ovr_70_99', ascending=False)
                    print(f"âœ… {len(qualified_batters)} batters")

            # PITCHERS - NEW OVR SYSTEM!
            if ptype in ['pitcher', 'both']:
                pitcher_df = build_pitcher_df(year, paths)
                print(f"Pitcher DF shape: {pitcher_df.shape}")

                if not pitcher_df.empty:
                    # ðŸ‘ˆ PITCHER-SPECIFIC OVR!
                    pitcher_df = calculate_pitcher_ovr(pitcher_df)

                    pitcher_df['age'] = pitcher_df['age'].apply(safe_numeric)
                    pitcher_df['IP'] = pitcher_df['IP'].apply(safe_numeric)

                    qualified_pitchers = pitcher_df[
                        (pitcher_df['IP'] >= 40) &
                        (pitcher_df['ovr_70_99'] > 0)
                    ].sort_values('ovr_70_99', ascending=False)

                    print(f"âœ… {len(qualified_pitchers)} pitchers (IPâ‰¥40, OVR {qualified_pitchers['ovr_70_99'].min():.0f}-{qualified_pitchers['ovr_70_99'].max():.0f})")

            # Dropdown options
            batter_options = [(f"âš¾ {row['playername']} ({int(row['ovr_70_99'])}/{int(row['age'])}/{int(row['PA'])})",
                             f"B-{row['playerID']}") for _, row in qualified_batters.iterrows()]

            pitcher_options = [(f"âš¾ï¸ {row['playername']} ({int(row['ovr_70_99'])}/{int(row['age'])}/{int(row['IP'])})",
                              f"P-{row['playerID']}") for _, row in qualified_pitchers.iterrows()]

            if ptype == 'batter':
                player_options = batter_options
            elif ptype == 'pitcher':
                player_options = pitcher_options
            else:
                player_options = batter_options + pitcher_options

            player_dropdown.options = player_options
            player_dropdown.disabled = False if player_options else True
            player_dropdown.value = None

            print(f"âœ… FINAL: {len(batter_options)} batters + {len(pitcher_options)} pitchers")

        except Exception as e:
            print(f"âŒ Error: {e}")

    def filter_players(change):
        if player_search.value:
            current_options = player_dropdown.options or []
            filtered = [opt for opt in current_options if player_search.value.lower() in str(opt[0]).lower()]
            player_dropdown.options = filtered
        else:
            load_year_players()

    def plot_career_progress(change):
        if change and change.get('new'):
            player_key = change['new']
            year = year_dropdown.value
            ptype = 'pitcher' if player_key.startswith('P-') else 'batter'
            player_id = player_key.split('-')[1]

            with output:
                clear_output(wait=True)
                print(f"ðŸ“ˆ {ptype.title()} career...")

                if player_key not in player_careers:
                    career_data = []
                    first_year_found = False

                    for y in range(max(1980, year-15), year + 1):
                        try:
                            if ptype == 'batter':
                                df = build_batter_df(y, paths)
                                pa_col, threshold = 'PA', 100
                                df = scout_ratings(df)
                                models, feats = train_predict_models_batters(y)
                                df = apply_ai_models_batters(df, models, feats)
                            else:
                                df = build_pitcher_df(y, paths)
                                pa_col, threshold = 'IP', 40
                                df = calculate_pitcher_ovr(df)  # ðŸ‘ˆ Pitcher OVR!

                            if df.empty: continue

                            df['age'] = df['age'].apply(safe_numeric)
                            df[pa_col] = df[pa_col].apply(safe_numeric)
                            df['ovr_70_99'] = df['ovr_70_99'].apply(safe_numeric)
                            df['potential_70_99'] = df.get('potential_70_99', 75).apply(safe_numeric)

                            player_row = df[df['playerID'] == player_id]
                            if not player_row.empty and safe_numeric(player_row[pa_col].iloc[0]) >= threshold:
                                row = player_row.iloc[0]
                                if not first_year_found:
                                    first_year_found = True
                                    is_first = True
                                else:
                                    is_first = False

                                career_data.append({
                                    'year': y, 'age': safe_numeric(row['age']),
                                    'ovr_70_99': safe_numeric(row['ovr_70_99']),
                                    'potential_70_99': safe_numeric(row['potential_70_99']),
                                    'is_first': is_first,
                                    'playername': row.get('playername', f"ID-{player_id}")
                                })
                        except:
                            continue

                    player_careers[player_key] = pd.DataFrame(career_data)

                df_career = player_careers[player_key].dropna(subset=['age', 'ovr_70_99'])
                if df_career.empty:
                    print("âŒ No career data")
                    return

                first_season = df_career[df_career['is_first'] == True].iloc[0] if 'is_first' in df_career and any(df_career['is_first']) else df_career.iloc[0]
                current_row = df_career[df_career['year'] == year].iloc[0]

                plt.figure(figsize=(14, 8))
                plt.plot(df_career['age'], df_career['ovr_70_99'], 'o-', linewidth=3, markersize=12, color='#2E86AB', label='OVR')
                plt.plot(df_career['age'], df_career['potential_70_99'], 's-', linewidth=3, markersize=12, color='#A23B72', label='Potential')
                plt.scatter([first_season['age']], [first_season['ovr_70_99']], s=250, color='gold', edgecolors='black', linewidth=3, zorder=5, label=f'First (Age {int(first_season.age)})')
                plt.scatter([current_row['age']], [current_row['ovr_70_99']], s=300, color='red', edgecolors='darkred', linewidth=4, zorder=5, label=f'{year} (Age {int(current_row.age)})')
                plt.axvline(x=27, color='gray', linestyle='--', alpha=0.6, label='Peak Age (27)')
                plt.title(f"{df_career['playername'].iloc[0]}\n{'âš¾ï¸ Pitcher' if ptype=='pitcher' else 'âš¾ Batter'}", fontsize=16, fontweight='bold')
                plt.xlabel('Age'); plt.ylabel('OVR'); plt.grid(True, alpha=0.3); plt.legend(); plt.xticks(range(18, 45)); plt.ylim(55, 105)
                for _, row in df_career.iterrows():
                    plt.annotate(f'{int(row.year)}', (row.age, row.ovr_70_99), xytext=(5,5), textcoords='offset points', fontsize=9)
                plt.tight_layout(); plt.show()
                display(df_career[['year', 'age', 'ovr_70_99', 'potential_70_99']].round(1))

    year_dropdown.observe(lambda c: load_year_players(c), names='value')
    player_type.observe(lambda c: load_year_players(c), names='value')
    player_dropdown.observe(plot_career_progress, names='value')
    player_search.observe(filter_players, names='value')

    load_year_players()

    display(widgets.VBox([
        widgets.HTML("<h2>ðŸ† Batters + Pitchers (Custom Pitcher OVR!)</h2>"),
        year_dropdown, player_type, player_search, player_dropdown, output
    ]))

# RUN:
interactive_career_progress(paths)